# Java基础面试

## JDK和JRE之间的差异是什么？
Java运行环境 JRE (Java Runtime Enviroment) 是运行Java程序的基本的Java虚拟机，包括执行applet的浏览器插件。JDK (Java Development Kit) 是为了开发，编译和执行Java应用程序，针对Java的全功能的软件开发包，包含了JRE，编译器和工具(比如说 JavaDoc 和Java Debugger)。

## 什么是JVM? 为什么称Java为跨平台的编程语言? 
Java虚拟机(Java Virtual Machine)是可以执行Java字节码的虚拟机，每个Java源文件将被编译成字节码文件，然后在JVM中执行。Java之所以被设计成可以在任意的平台运行，而不需要重写或者在不同的平台下重新编译，这些都要归功于Java虚拟机(JVM),因为JVM非常了解特定的指令的长度以及底层硬件平台的特殊性。

## Java的”一次编写，处处运行”是如何实现的？
Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。

## JVM自身会维护缓存吗？
是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象

## Java中垃圾回收的目的是什么，它什么时候被使用 ?
垃圾回收用于识别和丢弃程序不再需要的对象，以便回收和复用资源。

## System.gc() 和Runtime.gc()方法用途? 
些方法用于提醒JVM开始垃圾回收，然而开始垃圾回收的时机是由JVM决定的。

## finalize()什么时候被调用 ? 
finallize方法是在释放该对象内存前由gc(垃圾回收器)调用，通常建议在这个方法中释放该对象持有的资源。

## 如果一个对象的引用被设置为null，gc会立即释放该对象的内存么? 
会，这个对象将会在下一次gc循环中被回收。

## Serial 垃圾回收器与 Throughput 垃圾回收器区别 ? 
Throughput垃圾回收器使用并行版本的新生代回收器，它用于中到大型数据集的应用。 另一方面，Serial回收器通常足以应对大多数的小应用(在现代处理器上不会超过约100MB的堆内存)。

## 什么时候对象会被回收 ? 
当当前程序无法访问到某个对象时，该对象将被回收。

## 垃圾回收发生在指定的JVM区域 ?
垃圾回收在 PermGen 里发生。如果 PermGen满了或是到了瓶颈，就会触发完全回收。如果仔细 观察垃圾回收过程，会发现PermGen最后也被回收了.。这就是为什么要设置合理的PermGen大小以避免完全垃圾回收。

## Java堆的结构是什么?
堆中的Perm Gen(全称是Permanent Generation)空间是什么 ? 

JVM有一个运行时数据区，即堆(heap)。所有的类实例和数组的内存都是从堆中分配的。它在JVM启动时被创建，对象所占用的堆内存会被一个称为垃圾回收器的自动内存管理系统收回。

堆内存中包含活的和死的对象，活的对象可以被程序访问并且不会被垃圾回收， 死的对象是那些不会被程序访问的， 但还没有被垃圾回收器收回的对象， 这种对象会占用堆内存空间直到最终被垃圾回收器收回。

## Java支持多继承吗？
Java不支持多继承，每个类只允许继承一个类，但是可以实现多个接口。

## 什么是反射API？它是如何实现的？
反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field，Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。

## 传引用和传值
当对象通过传值调用时，传递的是这个对象的一个拷贝。因此，即使函数修改这个对象，也不会影响原对象的值。

当对象通过传引用调用时，对象本身没有被传递，而传递的是对象的一个引用。因此，外部函数对这个对象的修改，也会反映到任何出现这个对象的地方。

在java中，只有值传递。引用传递其实也就是内存地址值的传递。

## 接口和抽象类有什么不同？
Java同时提供和支持抽象类和接口，它们的实现有一些共同的特点，也有如下不同：

* 接口中所有的方法默认都是抽象的，而抽象类可以同时包含抽象和非抽象的方法。
* 一个类可以实现多个接口，但它只能继承一个抽象类。
* 一个类要实现某个接口，必须实现这个接口声明的所有方法。而一个类不需要实现抽象父类中声明的所有方法，不过，这时候这个类也必须声明为抽象类。
* 抽象类可以实现接口，而且不需要实现接口中的方法。
* 接口中声明的变量默认是final的，而抽象类可以包含非final的变量。
* 接口中的成员默认是public的，而抽象类的成员可以是private，protected，或public的。
* 接口是绝对抽象的，不可实例化，抽象类也不可以实例化，但可以在main方法中触发实例化（注：通过匿名类实现）。

## Java内部类的作用
内部类可直接访问外部类的属性

Java中内部类主要分为成员内部类、局部内部类(嵌套在方法和作用域内)、匿名内部类（没构造方法）、静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）

## Java中构造函数、构造函数重载的概念和拷贝构造函数
当类的对象被创建的时候，调用它的构造函数。每个类都有一个构造函数。如果程序员没有为类编写构造函数，Java编译器自动为类创建一个缺省的构造函数。 构造函数重载和Java中函数重载类似，可以为同一个类创建不同的构造函数，每个构造函数必须拥有唯一的参数列表。 Java与C++不同，它不支持拷贝构造函数，但是区别仅仅是，如果你没有编写类的拷贝构造函数，Java不会自动创建它。

## 在Java中什么是方法的 Override(覆盖) 和 Overload(重载)? 
Java中方法的 overload 发生的条件是，同一个类里，有两个或以上的方法名称完全相同，但参数列表不同。另一方面，方法的 override 是指，子类重定义了父类里的同一个方法。

Override 的方法必须方法名、参数列表和返回类型都完全相同。Override 的方法不会限制原方法的访问权限。

##  “static” 关键字是什么意思？在Java里可以 override static 的方法吗？
static 关键字表示，访问这个成员变量或方法时，不必获取它属于的类的实例。 

Java 里的 static 方法不能被 override，因为 override 的机制是运行时(runtime)的动态绑定，而 static 方法是在编译时静态绑定的。static 方法并不与任何类的具体实例有关，因此无法应用继承的概念。

## 静态类型有什么特点?
静态变量是和类绑定到一起的，而不是类的实例对象。每一个实例对象都共享同样一份静态变量。

也就是说，一个类的静态变量只有一份，不管它有多少个对象。类变量或者说静态变量是通过static这个关键字来声明的。类变量通常被用作常量。静态变量通常通过类名字来进行访问。当程序运行的时候这个变量就会创建直到程序结束后才会被销毁。类变量的作用域和实例变量是一样的。它的初始值和成员变量也是一样的，当变量没被初始化的时候根据它的数据类型，会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，它的调用并不作用于类对象，也不需要创建任何的类实例。

静态方法本身就是final的，因为重写只会发生在类实例上，静态方法是和类绑定在一起的，不是对象。父类的静态方法会被子类的静态方法屏蔽，只要原来方法没有声明为final。非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法。非静态变量在每一个对象实例上都有单独的一份值。

## 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？
当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。

## 说明一下public static void main(String args[])这段声明里每个关键字的作用
* public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为pulic.
* static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。
* void: main方法没有返回值。
* String是命令行传进参数的类型，args是指命令行传进的字符串数组。

## 介绍一下finalize方法
final: 常量声明。 finally: 处理异常。 finalize: 帮助进行垃圾回收。
 
接口里声明的变量默认是final的。final类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如String和Integer。这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。finalize()方法在一个对象被销毁和回收前会被调用。finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如，关闭连接通常放到finally块中完成。

## 在静态方法里可以访问非静态变量吗? 
Java 中的 static 变量归相应的类所有，它的值对于类的所有实例都是相同的。

static 变量是在 JVM 加载类的时候初始化的。如果代码试图访问非静态的变量，而且不是通过类的实例去访问，编译器会报错，因为这些非静态变量还没有被创建呢，并且它们没有与实例相关联。

## Java中的两种异常是什么?
Java有两种类型的异常:checked与unchecked(检查与未检查) 异常。如果unchecked异常可能会在方法或构造函数的执行时被抛出从而蔓延到方法或构造函数的外部，它们也不需要要在方法或构造函数中声明throws子句。 然而，checked异常必须通过方法或构造函数的throws子句声明。关于java异常处理的建议请参考这里Java exception handling。

## Java中异常与错误的区别? 
Exception和Error都是Throwable类的子类。Exception用于用户程序需要捕获的异常条件。Error定义了用户程序不可预见的异常

## throw与throws的区别 ?
关键字throw用于在程序中显式地抛出一个异常。相反，throws子句用于指出在该方法中没有处理的异常。每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常。最后，多个异常用逗号分隔。

## 异常处理中finally语句块的重要性? 
不管程序是否发生了异常，finally语句块都会被执行。甚至当没有catch声明但抛出了一个异常时，finally语句块也会被执行。最后要说一点: finally语句块通常用于释放资源， 如I/O缓冲区，数据库连接等等。

## 异常被处理后异常对象会发生什么? 
异常对象会在下次gc执行时被回收。

##  怎样区分finally语句块与finalize()方法? 
不管是否抛出异常finally语句块都会被执行，它通常用于释放程序持有的资源。finalize是Object类中的一个protected方法，当一个对象被gc回收前它会被jvm调用。

## Serializable 和Parcelable 的区别 
Serializable Java 序列化接口 在硬盘上读写 读写过程中有大量临时变量的生成，内部执行大量的i/o操作，效率很低。
Parcelable Android 序列化接口 效率高 使用麻烦 在内存中读写（AS有相关插件 一键生成所需方法），对象不能保存到磁盘中

## synchronized 和volatile 关键字的区别 
1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

## Java中==和equals的区别，equals和hashCode的区别
基本数据类型的==比较的值相等。

类的==比较的内存的地址，即是否是同一个对象，在不覆盖equals的情况下，同比较内存地址，原实现也为 == ，如String等重写了equals方法。

hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等比较是否为同一个）

如果两个对象equals，Java运行时环境会认为他们的hashCode一定相等。

如果两个对象不equals，他们的hashCode有可能相等。

如果两个对象hashCode相等，他们不一定equals。

如果两个对象hashCode不相等，他们一定不equals。

## hashCode() 和 equals() 方法重要性何在 ? 
Java中的 HashMap 使用 hashCode 和 equals方法来确定键值对的索引。根据键去查询对应的值时，同样会用到这两个方法。如果这两个方法没有正确实现，两个不同的键可能会产生相同的 hash 值，因此会被 collection 认为是相同的。并且，这两个方法在检测重复时也会用到。因此，这两个方法都要正确实现，对 HashMap 的正确性和效率都至关重要。

## switch中的小括号能使用string类型的数据吗
只用JDK1.7版本以后才可以使用String类型数据

long类型数据任何版本都不可以使用

## String StringBuffer StringBuilder区别
String：字符串常量 不适用于经常要改变值得情况，每次改变相当于生成一个新的对象

StringBuffer：字符串变量 （线程安全）

StringBuilder：字符串变量（线程不安全） 确保单线程下可用，效率略高于StringBuffer

## Java Int和Integer的区别
Int 基本类型 

Integer 对象 Int的封装类

## Java的数据类型
分别是8种基本数据类型:byte、short、int、long、float、double、boolean、char

除8种以外统称为引用类型,例如:String类、Object类、数组及自己创建的类等

## &操作符和&&操作符有什么区别?
当一个&表达式在求值的时候，两个操作数都会被求值，&&更像是一个操作符的快捷方式。当一个&&表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。

## Java是如何处理整型的溢出和下溢的?
Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。

## 什么是进程、线程和协程
* 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

* 线程

线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

* 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## 进程、线程和协程的区别

#### 进程多与线程比较

线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:

* 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
* 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
* 线程是处理器调度的基本单位,但进程不是
* 二者均可并发执行
* 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

#### 协程多与线程进行比较

* 一个线程可以多个协程，一个进程也可以单独拥有多个协程
* 线程进程都是同步机制，而协程则是异步
* 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

##  解释下可用的线程状态. 
在执行期间，线程会处于以下状态中的一种:

* Runnable: 线程已准备就绪，但没有立即运行.
* Running: 处理器正在执行的线程代码.
* Waiting: 处于阻塞状态的线程，等待外部某种处理的结束.
* Sleeping: 被强制休眠的线程.
* Blocked on I/O: 等待I/O操作的完成.
* Blocked on Synchronization: 等待取得线程锁.
* Dead: 线程已经执行结束.


## 同步方法与同步块的区别 ?
在Java程序中，每个对象都拥有一个锁。线程可以通过使用synchronized关键字来获取一个对象上的锁。synchronized关键字可以用于方法级别(粗粒度锁)或代码块级别(细粒度锁)。

## 在监视器中的线程同步是怎样发生的? 
你可以使用哪些级别的同步 ? JVM使用结合了监视器的锁。监视器是一个守护者，它看管一个同步代码的序列，并且确保在一个时刻只能有一个线程执行同步代码片段。每个监视器关联着一个对象引用，只能得到锁的线程才可以执行同步代码。

## 什么是死锁 ? 
当两个进程相互等待对方执行完毕时，其结果是它们会永远等待下去。

## 怎样确保N个线程访问N个资源时不会发生死锁 ? 
使用N个线程时一个非常简单的避免死锁的方法是为所有的锁排序，并强制每个线程也按那种方式排序。这样，如果所有线程以相同的顺序锁定和解锁互斥资源就不会发生死锁了。

## Java中的多线程相关的内容以及各种相关的锁。
实现Java中的多线程有两种方式。一是直接继承Thread类，二是实现Runnable接口。通常我们实现Runnabale接口方式去做。好处如下：

1. 适合多个相同程序代码的线程去处理同一资源的情况，把虚拟CPU（线程）同程序的代码，数据有效的分离，较好地体现了面向对象的设计思想。
2. 可以避免由于Java的单继承特性带来的局限。我们经常碰到这样一种情况，即当我们要将已经继承了某一个类的子类放入多线程中，由于一个类不能同时有两个父类，所以不能用继承Thread类的方式，那么，这个类就只能采用实现Runnable接口的方式了。
3. 有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。当多个线程的执行代码来自同一个类的实例时，即称它们共享相同的代码。 多个线程操作相同的数据，与它们的代码无关。当共享访问相同的对象是，即它们共享相同的数据。当线程被构造时，需要的代码和数据通过一个对象作为构造函数 实参传递进去，这个对象就是一个实现了Runnable接口的类的实例

Java中多线程的状态是:

1. 新建状态（New）：新创建了一个线程对象。
2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
Java多线程锁有对象锁和类锁。对象级别锁是一个机制，当你想同步一个非静态方法或者非静态代码块，让在给定的类实例中只有一个线程来执行这个代码块，这就可以使得实例级别的数据是线程安全的。类级别锁是在所有可变的实例或者运行环境中，类级别锁阻止多线程进入同步块，也就是说，如果运行环境中有DemoClass的100个实例，在任何时刻，只能有DemoClass的一个实例来执行它的demoMethod()方法，所有其他的DemoClass实例在其他线程中只能处于阻塞状态，这使得静态数据是线程安全的。

## 方法可以同时即是static又是synchronized的吗?
可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁

## transient变量有什么特点?
transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。

## Java Collections框架的基本接口 ?
Java Collections 框架 提供了一系列支持对象集合操作的设计良好的接口和类. Java Collections框架中最基础的接口是:

* Collection，表示一组对象(元素)
* Set，包含非重复元素的集合
* List，包含非重复元素的有序集合
* Map，包含非重复键的键值对的对象

## 为什么Collection没有继承Cloneable和Serializable接口 ?
Collection接口描述的是由元素组成的对象组。Collection的每一个具体实现可以选择自己的方式来管理元素。 一些集合允许存在重复键，另一些则不允许。
当处理实际实现时复制和序列化的语义和效果才会起作用. 因此，集合类的具体实现应该决定它们将怎样被复制和序列化。

## 什么是Iterator(叠代器)
 Iterator接口提供了许多能够叠代集合的方法。每个java集合(Collection)都含有一个返回Iterator实例的iterator方法。叠代器在叠代过程中能够移除底层集合中的元素。
 
## Iterator 和ListIterator之间的不同 ? 
* Iterator能够遍历Set和List集合，而ListIterator只能用来遍历List。
* Iterator只能正向遍历集合，而ListIterator可以双向遍历List。
* ListIterator实现了Iterator接口并提供了额外的功能，例如添加元素，替换元素，取得上一个或上一个元素索引，等等。

## fail-fast与fail-safe的区别? 
Iterator的fail_safe特性是对底层集合的拷贝进行操作，因此对集合的任何改变都不会有影响。java.util包下的所有集合类是fail-fast的，但java.util.concurrent包下的集合类是fail-safe的。fail-fast叠代器会抛出ConcurrentModificationException，而fail-safe叠代器不会抛出这种异常。

##  Java中的 HashMap 是怎么工作的? 
Java 中的 HashMap 是用来存储键值对的。 HashMap 需要一个 hash 函数，它使用 hashCode 和 equals 方法，来进行 collection 中元素的保存和查找。调用 put 方法时，HashMap 会计算键(key)的 hash 值，然后将键值对存到 collection 的适当索引下。如果键已经存在，那么相应的值会更新。HashMap 的重要特征主要有它的容量，装载因子(load factor)和容量扩充(threshold resizing)。

## HashMap与HashTable之间有哪些不同？
HashMap、HashTable这两个类都实现了Map接口，因此有些非常相似的特征，但他们在以下特性中又有所不同：

* HashMap的key与value都允许null值的存在，而HashTable则既不允许key为null，也不允许value为null。
* HashTable是线程同步的，而HashMap则不是。因此，在单线程环境下HashMap是首选，而HashTable更适合在多线程环境下使用。
* HashMap提供了它键的set集合，因此Java程序可以通过set进行迭代。因此，HashMap是快速失败的。另一方面，HashTable提供了它键的枚举。
* HashTable类被当做遗留类

## Array与ArrayList间有什么不同？
 与ArrayList相比你什么时候会用Array？ Array与ArrayList类在以下特性中有所区别：

* Array可以包含基础数据类型或者对象，而ArrayList只能包含对象。
* Array有固定长度，而ArrayList长度则是动态的。
* ArrayList类提供了更多的方法和特性，比如addAll,removeAll,iterator,等等

对于一个基础数据类型的list，集合框架使用了自动装箱去减少编码的工作。但针对固定长度的的基础数据类型，这种方法会使得它们变得更慢。

## ArrayList与LinkedList间有什么不同？
ArrayList、LinkedList这两个类都实现了List接口，但他们以下特性中又有所不同：

* ArrayList是基于索引的数据结构，底层由Array支持实现。它提供了以时间复杂度为O(1)的性能随机访问它的元素，另一方面，LinkedList以元素列表的方式来存储它的数据，每一个元素与它前一个和后一个元素都是相连的。对元素查询操作的时间复杂度为O(n).
* 对元素的插入、添加、移除操作，与ArrayList相比，LinkedList更快，因为，当一个元素被添加到集合内部的任意位置时，LinkedList不需要重新调整数组大小或者更新索引。
* LinkedList比ArrayList消耗更多的内存，因为LinkedList中每一个节点都存储了两个引用，一个是它前一个元素，一个是它后一个元素 也可以查看我们的文章ArrayList vs. LinkedList

## Comparable 和 Comparator 接口分别是什么 ? 

列出它们的区别。 Java 提供的 Comparable 接口，其中只包含一个方法，就是 compareTo。这个方法会比较两个对象，从而得出它们的顺序关系。具体来说，它会返回一个负整数，零，或一个正整数，分别表示传入的对象小于，等于或大于已有的对象。 Java 提供的 Comparator 接口，包含两个方法，compare 和 equals 。compare 方法比较两个参数，得出它们的顺序关系。它会返回一个负整数，零，或一个正整数，分别表示第一个参数小于，等于或大于已有的对象。equals 方法有1个参数，它用来确定参数对象是否等于这个 camparator。这个方法仅在要比较的对象也是一个 comparator，同时它的序关系与这个 comparator 相同时，才会返回 true。

## Java Priority Queue是什么? 
PriorityQueue是一个基于优先级堆的无界队列，它的元素都以他们的自然顺序有序排列。在它创建的时候，我们可以可以提供一个比较器(Comparator)来负责PriorityQueue中元素的排序。PriorityQueue不允许null元素，不允许不提供自然排序的对象，也不允许没有任何关联Comparator的对象。最后，PriorityQueue不是线程安全的，在执行入队和出队操作它需要O(log(n))的时间复杂度。

## 如何权衡有序数组和无序数组 ? 
有序数组最关键的优势在于搜索的时间复杂度为 O(log n)，而无序数组的时间复杂度是 O (n)。有序数组的劣势就在于插入操作的时间复杂度为 O(n)，因为较高值的元素需要挪动位置腾出空间给新元素。与之不同的是，无序数组的插入操作的时间复杂度为 O(1)。

## 有哪些关于 Java 集合框架的最佳实践？
基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array，而不是 ArrayList。

一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。

总是使用泛型来保证类型安全，可靠性和健壮性。同时，使用泛型还可以避免运行时的 ClassCastException。

在 Map 中使用 Java Development Kit (JDK) 提供的不可变类作为一个 key，这样可以避免 hashCode 的实现和我们自定义类的 equals 方法。
应该依照接口而不是实现来编程。

返回零长度的集合或者数组，而不是返回一个 null ，这样可以防止底层集合是空的。

## Enumeration 和 Iterator 接口有什么不同 ?
Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。

## HashSet 和TreeSet 有什么不同?
HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1)。
另一个方面，TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn)。

## int类型和string类型之间的互相转换
int -->String常用的方法:

字符串拼接
String b = String.valueof(int a)方法

String -->int常用的方法:

int i = Integer.valueof(String a)方法

int i = Integer.parseInt(String a)方法

## Java泛型中的泛型参数能不能是基本类型
泛型要求能包容的是对象类型，而基本类型在java里不属于对象。

ArrayList<String>中不可以插入数字，因为他的泛型参数规定是String类型，所以只能插入字符串。但是如果非要插入数字，有三种方法可以解决。比如泛型参数改成Integer，或者不声明泛型类型或者是数字和空字符串拼接。